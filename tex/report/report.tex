%% 報告書の LaTeX サンプル
%%	（version 4.9） 2020/06/03

%\documentclass[bigbox]{jarticle}
\documentclass{jarticle}[11pt]
%\documentstyle[bigbox,fancybox]{jarticle}

% コマンドの定義
%
% コメントアウト用のコマンド
%   複数行にまたがる記述をまとめてコメントアウトする際に利用できる
%   \COMMENT{ .... } で .... の部分をコメントアウト
% 以下は，表（srmmary.tex）で使用しているコマンド

%% 使用しているパッケージ等があれば，宣言しておく
\usepackage{ascmac}
\usepackage{graphicx}

% 以下のパラメータは，見易いように適宜調整する．
\topmargin = -1cm
\textheight = 24cm
\textwidth = 15.5cm
\oddsidemargin = -.2cm
\evensidemargin = -.2cm

%% 報告書のタイトル，提出者，提出日等
%% これらのための専用の表紙を設ける必要はない．

%% 以下のタイトルは適切に変更すること
%% 「（の書き方）」も消すこと
\title{{\normalsize 情報工学実験A（ハードウェア）報告書}} 

%% 自分の学生番号と名前に変更すること．
\author{ 
  学生番号: 09430509 \\
  提出者: 今田　将也 \\
  E-mail: psc06fz8@s.okayama-u.ac.jp
}

%% 提出日を記載する．
\date{
  提出日: 2020年 6月11日（木） \\　%% <-- 提出日を記載のこと
  締切日: 2020年 6月11日（木）12:00     %% <-- 締切日を記載のこと
}

\begin{document}
\maketitle

\begin{abstract}
  本稿では，情報工学実験A（ハードウェア実験）において作成した32ビットマイクロプロセッサp32の設計についてまとめる．
\end{abstract}

\section{はじめに}
本実験では，
ハードウェア記述言語とCAD（computer aided design）ツールを利用したマイクロプロセッサ設計を通して，
論理回路， コンピュータアーキテクチャ，およびコンピュータシステムに関する理解を深めることを目的とする．

本報告書では，ハードウェア記述言語とCADツールを用いた論理回路の設計と，
32ビットマイクロプロセッサの設計について報告する．本報告書の構成は次のとおりである．

% 次の行は，参考文献の引用例．〈文献のラベル〉を \cite{} で括る．

%情報工学実験テキスト \cite{bib:実験テキスト} の第1章から第3章の
%.... .... .... .... .... を報告する．

\begin{description}
  \item[第\ref{sec:設計したプロセッサの概要}章] 本実験で設計したプロセッサの概要について述べる.
  \item[第\ref{sec:実施状況の報告}章] 本実験における実施内容の状況報告を行う
  \item[第\ref{sec:プログラミング課題に関する報告}章] アセンブリで作成したプログラミング課題に関しての報告を行う．
  \item[第\ref{sec:追加課題や発展課題に関する報告}章] 発展課題で取り組んだ課題について報告する．
  \item[第\ref{sec:検討・考察}章] 諸事項について検討を行い，それについての考察を記述する．
  \item[第\ref{sec:工夫した点や特に力を注いだ点}章] 設計の際に工夫した点や特に注力した点について報告する．
  \item[第\ref{sec:本実験を実施して得られたこと}章] 本実験を通して，これまでから一層理解が深まった部分などについて記述する．
  \item[第\ref{sec:おわりに}章] 本報告のまとめと今後の課題を述べる． 
  \item[第\ref{sec:作成した設計記述，プログラム等のリポジトリ名，ファイル名の一覧}章] 本実験で作成したアセンブリ言語プログラム，設計したSFL記述，テスト用スクリプト，テスト結果，論理合成時の出力等のファイルの一覧を掲載する．
\end{description}

% fulladdar 実装したら早くなったことを書く．
% p32p1は遅くなってしまう．
% 4-2 OPcode　掛け算mfhi divu とかはできない．

\section{設計したプロセッサの概要}\label{sec:設計したプロセッサの概要}
本実験で設計する32ビットRISCマイクロプロセッサp32m1，p32m2および，p32p1のFSL記述の概要について述べる.

\begin{description}
  \item [p32m1]単純なマルチサイクルで実装されるプロセッサ．単一サイクルで１命令を５サイクルで行う．パイプライン実行は無い．
  \item [p32m2]１命令を2～5サイクルで実行するマルチサイクルのプロセッサ．パイプライン実行は無い．
  \item [p32p1]パイプライン実行により実装されたプロセッサ．５ステージパイプラインとフォワーディング機構を持つ．
\end{description}

p32m1，p32m2のプロセッサは1つの命令が終了するまで次の命令を実行せず，その命令が終了してから
次の命令を実行するような方式になっている。

p32p1はパイプライン実行を考慮した設計を行う．今回設計するプロセッサは5つのステージを持つため，同時で最大5命令実行することになる．

本プロセッサで使用するサブモジュールは、以下である。

% フォワーディング：WBまできたら，レジスタで使うかもしれないから，別のところに保管しておく．

\begin{itemize}
  \item レジスタファイル
    \begin{itemize}
      \item regs32x32（32ビットx32本の汎用レジスタ）
      \item 入力は1ポート
      \item 出力は2ポート
    \end{itemize}
  \item 演算ユニット
    \begin{itemize}
      \item p32ExecUnit
      \item マイクロプロセッサ p32 用の実行ユニットモジュール
    \end{itemize}
  \item デコードユニット
    \begin{itemize}
      \item p32DecodeUnit
      \item 命令をデコードし，レジスタファイルにアクセスして必要なレジスタを読み取る．処理すべき命令はIFから受け取り，その命令から命令コードとオペランドを展開し，必要に応じてレジスタの内容を取り出す．
    \end{itemize}
  \item alu32（32ビットALU）
    \begin{itemize}
      \item 32ビットの算術・論理演算
    \end{itemize}
  \item shift32（32ビットシフタ）
    \begin{itemize}
      \item 論理シフト・算術シフト
    \end{itemize}
  \item add32（32ビット加算器）
    \begin{itemize}
      \item 全加算器
    \end{itemize}
\end{itemize}


命令形式にはR形式，I形式，J形式がある．

また，遅延ロードがある．例えば，ロードされるデータはロード命令のMEMステージが終わるまで使用できない．
ステージについては以降で説明している．なお，分岐命令についても，IDステージで計算するため，IDステージが終わるまで利用できない．

\subsection{実装した基本命令セット}

本実験で実装した基本命令セットを表\ref{命令一覧}に示す．

\begin{itemize}
  \item 加算命令　add, addu, addi, addiu 
  \item 減算命令　sub, subu
  \item 論理積演算　and,andi 
  \item 論理和演算　or,ori
  \item 排他的論理和演算　xor,xori
  \item 否定演算　nor
  \item 比較命令

  \begin{description}
    \item[slt,slti] 符号付き３２ビット整数を比較するRsレジスタがRtレジスタより小さい場合に1
    \item[sltu, sltiu] 符号無し３２ビット整数を比較するRsレジスタがRtレジスタより小さい場合に1
  \end{description}

  \item シフト命令
   
  \begin{description}
    \item[sll,sllv] 0を下位ビットに挿入しshamtビットもしくは指定レジスタの下位５ビットで指定されるビットだけ左シフト
    \item[srl,srlv] 0を上位ビットに挿入しshamtビットもしくは指定レジスタの下位５ビットで指定されるビットだけ右シフト
    \item[sra,srav] 上位ビットを符号拡張しshamtビットもしくは指定レジスタの下位５ビットで指定されるビットだけ右シフト
  \end{description} 
  
  \item ロードストア命令
 
  \begin{description}
    \item[lw, lb] 有効アドレスで指定するメモリ位置のワードもしくはバイトを読み出す
    \item[sw, sb] 有効アドレスで指定するメモリ位置のワードもしくはバイトを書き出す
  \end{description} 

  \item 分岐命令

  \begin{description}
    \item[beq] 比較対象の２つのレジスタの内容の値が等しい場合に１命令遅れてターゲットアドレスに分岐
    \item[bne] 比較対象の２つのレジスタの内容の値が等しくない場合に１命令遅れてターゲットアドレスに分岐
  \end{description} 

  \item ジャンプ命令
  
  \begin{description}
    \item[j] 26ビットターゲット・アドレスを2ビット左詰めして，現在のプログラム・カウンタの上位4ビットと合成しジャンプ先のアドレスを計算．計算されたアドレスに1命令遅れで無条件に分岐
    \item[jr] 1命令遅れで汎用レジスタ rs に格納されたアドレスへ無条件で分岐
    \item[jal] 26ビットターゲット・アドレスを2ビット左詰めして，現在のプログラム・カウンタの上位4ビットと合成しジャンプ先のアドレスを計算．計算されたアドレスに1命令遅れで無条件に分岐．遅延スロットの後の命令のアドレスはリンクレジスタに格納
    \item[jalr] 1命令遅れで汎用レジスタ rs に格納されたアドレスへ無条件で分岐．遅延スロットの後の命令のアドレスを汎用レジスタ rd に格納  
  \end{description} 
  
  \item システムコール　
  \begin{description}
    \item[syscall] システムコール・トラップを発生させ，制御を無条件で例外ハンドラに移す
  \end{description} 

\end{itemize}

\begin{table*}[h] % table* だと1カラム配置（横長）の表になる
  \caption{命令一覧}
  \label{命令一覧}
  \begin{center}
  \begin{tabular}{c|c}
  
  \hline \hline

  命令種別 & 
  \multicolumn{1}{c}{実装した命令}
  \\ 
  
  \hline \hline
  
  加算命令&
  add, addu, addi, addiu 
  \\ \hline

  減算命令&
  sub, subu
  \\ \hline

  論理演算命令&
  and,andi, or,ori, xor, xori, nor
  \\ \hline

  比較 &
  slt, slti, sltu, sltiu
  \\ \hline
  
  シフト &
  sll,sllv, srl,srlv, sra, srav
  \\ \hline

  ロード・ストア &
  lw, sw, lb, sb
  \\ \hline
  
  分岐 & 
  beq, bne
  \\ \hline
  
  ジャンプ &
  j, jr, jal, jalr
  \\ \hline

  例外，システムコール &
  syscall
  \\\hline
  \end{tabular}
  \end{center}
  \end{table*}

\subsection{内部構造の概略}

5ステージパイプラインおよびマルチサイクル構造は以下のステージにより構成されている．

\begin{itemize}
  \item IFステージ: 命令メモリから命令をフェッチ
  \item IDステージ: レジスタの値を取り出したり，分岐処理を行う
  \item EXステージ: 演算を実行
  \item MEMステージ: メモリアクセス関連の処理を行う
  \item WBステージ: レジスタに書き込む
\end{itemize}

\subsection{処理方式の概略}

\begin{description}
  \item [単一サイクル] ５ステージに分かれているが，マルチサイクルとは異なり命令に必要なクロック数は５サイクルで変わらない
  \item [マルチサイクル] マルチサイクル方式のマイクロプロセッサは1命令を複数のステップに分け，各ステップを１クロックサイクルで実現し，５ステージに分かれているステップを繰り返しながら行う方式である．命令に必要なサイクル数が変わる．
  \item [パイプライン方式] 乗除算命令を除くすべての命令を５サイクルで並列に実行(IF/ID/EX/MEM/WB)する．毎サイクル毎に命令をフェッチし1サイクル当たり1命令を実行する．依存関係のある命令が同時刻にパイプライン内に存在する場合，先行命令の演算結果を利用するには，先行命令がWBステージにてレジスタファイルに結果を書き込むまで利用できないことを，データフォワーディング機構により解決している
\end{description}

データフォワーディングとは，パイプライン処理において次のクロックサイクルで次の命令を実行できないデータハザードを解消するための，
演算結果やメモリからロードした値がレジスタファイルに書き込まれるタイミング以前で利用できるように，必要な値をIDステージより後段の
ステージ（EX/MEM/WB）からバイパスする機構のことである．

\section{実施状況の報告}\label{sec:実施状況の報告}

どの課題に取り組んだのか，またその状況について，表\ref{プログラミング課題，設計課題および発展課題の実施状況}にまとめて報告する．

\begin{table*}[h] % table* だと1カラム配置（横長）の表になる
  \caption{プログラミング課題，設計課題および発展課題の実施状況}
  \label{プログラミング課題，設計課題および発展課題の実施状況}
  \begin{center}
  \begin{tabular}{l|l}
  \hline \hline
  課題 &
  状況
  \\ \hline \hline
  
  （プログラミング課題）&
  \\

  　１．【プログラミング課題１】N個の語の加算&
  (2)完了
  \\ 

  　２．【プログラミング課題２】N語のメモリコピー&
  (2)完了
  \\ 

  　３．【プログラミング課題３】乗算&
  (2)完了
  \\

  （設計課題２）&
  \\

  　４．【設計課題２－１】３２ビット加算器　add32&
  (2)完了
  \\ 

  　５．【設計課題２－２】３２ビットALU　alu32&
  (2)完了
  \\ 

  　６．【設計課題２－３】３２ビットシフタ shift32&
  (2)完了
  \\ 

  （発展課題２）&
  \\ 

  　７．【発展課題２－１】３２ビット整数乗算器　mult32&
  (2)完了
  \\

  　８．【発展課題２－２】３２ビット整数除算器　div32&
  (0)未実施
  \\

  （設計課題３）&
  \\

  　９．【設計課題３－１】レジスタファイル　regs32x32&
  (2)完了
  \\ 

  １０．【設計課題３－２】実行ユニット　p32ExecUnit&
  (2)完了
  \\ 

  １１．【設計課題３－３】デコードユニット p32DecodeUnit&
  (2)完了
  \\ 

  （設計課題４）&
  \\

  １２．【設計課題４－１】プロセッサ　p32m1&
  (2)完了
  \\ 

  １３．【設計課題４－２】プロセッサ　p32m2&
  (2)完了
  \\ 

  １４．【設計課題４－３】プロセッサ p32p1&
  (2)完了
  \\ 

  （発展課題４）&
  \\

  １２．【発展課題４－１】改良&
  (2)完了
  \\ 

  １３．【発展課題４－２】乗算機能の実装&
  (0)未実施
  \\ \hline

  \end{tabular}
  \end{center}
  \end{table*}

  \section{課題に関する報告}\label{sec:プログラミング課題に関する報告}

  \subsection{プログラミング課題に関する報告}
  アセンブリ言語でプログラミングする際，遅延スロットに注意した．
  \begin{itemize}
    \item 遅延ロード
    \begin{itemize}
      \item ロード命令は，ロードされるデータを別の命令が使用できるようになるまでに1サイクルの遅延（待ち時間）がある
    \end{itemize}
    \item 遅延分岐
    \begin{itemize}
      \item ジャンプ命令および分岐命令は，分岐を実行する場合には命令とターゲットアドレスを取り出す間，1サイクルの遅延がある
    \end{itemize}
  \end{itemize}

  この問題は，nop命令を差し込むことで遅延を処理した．

  \subsubsection{プログラミング課題１}
 
  データセグメントのアドレス0x10004100から置かれたN個のワードデータの加算を行なう
  p32アセンブリ言語のプログラムを作成し，MAPSシミュレータにて動作を確認した．

  2通りの方法を実施した，１つ目はmainに直接書くバージョンである．
  ここでは，データの個数，データの格納されている先頭アドレス及び計算結果格納用のレジスタを用意して，
  それぞれに初期化を行い，LOOP処理を実装した．
  MAPSでは，runを行ったあと，0x10004000番地をprintすることで結果を確認できる．

  ２つ目は，サブルーチンとして呼び出す方法である．mainで行う方法と特に変わることは，MIPSのときのmoveが使えなかったため
  add命令を用いて値をゼロと加算することで擬似的に移動したようにして実装をした．
  
  \subsubsection{プログラミング課題２}

  アドレスsrcから始まるNワードのデータをアドレスdestから始まる領域に
  コピーするC言語の以下の関数に対応するアセンブリ言語プログラムを作成し，
  MAPSシミュレータで動作を確認した．

  \verb| int *memcopy(int *dest, int *src, int n);|

  まずdestの値，srcの値，nの値を読み出す．LOOP処理で加算するアドレスを4ずつ追加して，destとsrcをそれぞれ１バイトずつずらしながら
  ワードを読み込んで繰り返す．最後にdestを返して呼び出し元に返している．

  \subsubsection{プログラミング課題３}

  2個の32ビットの無符号整数値を受取り，それらの積を計算し， 64ビットの乗算結果を返すサブルーチンを作成した．
  サブルーチンへの引数は被乗数を\verb|$a0|で，乗数を\verb|$a1|でそれぞれ与え，結果は，上位ワードを\verb|$v0|に，
  下位ワードを\verb|$v1|に格納している．なお，作成したプログラムはMAPSシミュレータにて動作確認を行った．
  
  動作内容としてはまず，かけられる数とかける数を用意した後に，かける数の最下位ビットが１かどうか判定する．１ならば計算を行うので，結果のレジスタに
  足し込む．その後結果の上位ワードを１ビット右シフトさせる．その後，規定の回数分のループが終了していなければ，結果の下位ビットとかける数を右シフトさせる．
  乗数（例えば10, ２進数で1010）のビットが立っているとき，被乗数のを桁を揃えて（これがシフトに相当）足し込んでいく．
  乗数の各ビットをLSB側（最下位ビット側）からみて， ビットがたっていたら（ビットが1なら） 被乗数を足し込んでいく繰り返しの処理を行っている．

  \subsection{プロセッサ設計課題に関する報告}

  マイクロプロセッサp32のモジュールとなるp32m1，p32m2，p32p1の設計を行った．

  設計に際しての動作確認については，gitbucket上に配布されているブランチをフォークし，verilog, vvp, simについてはMAPSを用いて，
  シミュレーション結果と比較用パターンの差分を確認し，差分がないことを確認した．

  そして，各プロセッサをFPGA向けに論理合成，配置配線，および静的タイミング解析を行なった．このプロセッサは後に改良を行ったため，
  ここでは改良前の諸量を表\ref{FPGAへの論理合成などで得られた諸量のまとめ}にまとめる．

  \begin{table}[h]
    \caption{FPGAへの論理合成などで得られた諸量のまとめ}
    \label{FPGAへの論理合成などで得られた諸量のまとめ}
    \begin{tabular}{l|ccccc}
      \hline \hline
               & \multicolumn{2}{c}{最大動作周波数　Fmax（MHz）} &          &          &            \\
      モジュール      & 85℃Model       & 0℃Model       & LE数（使用率） & CF数（使用率） & レジスタ数（使用率） \\ \hline
      プロセッサp32m1 & 61.36           & 67.40          & 3680（3％）   & 3631（3％）    & 1379（1％）         \\
      プロセッサp32m2 & 62.19           & 68.04          & 3719（3％）   & 3687（3％）    & 1379（1％）           \\
      プロセッサp32p1 & 64.88           & 71.15          & 4052（4％）   & 4025（4％）    & 1416（1％）            \\ \hline
    \end{tabular}
  \end{table}

  \subsubsection{考察}\label{sec:考察１}
  
  他の人との結果と比較しても特に特筆して優れていた点，及び低い点は見当たらなかった．
  add32のサブモジュールや，shift32のサブモジュールは，算術演算子及び論理演算による実装が可能であるため，
  差が出るとすればそこだと考えプロセッサ設計に予めふくまれてソースコードに則った部分の改良よりも，
  サブモジュールの改良を行った．

  具体的には，１つ目は算術演算子により実装していたshift32サブモジュールを，論理演算によるシフト演算へ変更を行った．
  ２つ目に，算術演算子により実装していたadd32加算器のサブモジュールは，論理演算に落とし込む事ができるため，
  論理演算による全加算器を作成．全加算器は１ビットに対応するため，２ビットの加算サブモジュールを作成し，add32を改良した．
  するとp32m1，p32p1について表\ref{FPGAへの論理合成などで得られた諸量のまとめ【改良後】}のように改良できた．

  \begin{table}[h]
    \caption{FPGAへの論理合成などで得られた諸量のまとめ【改良後】}
    \label{FPGAへの論理合成などで得られた諸量のまとめ【改良後】}
    \begin{tabular}{l|ccccc}
      \hline \hline
               & \multicolumn{2}{c}{最大動作周波数　Fmax（MHz）} &          &          &            \\
      モジュール      & 85℃Model& 0℃Model& LE数（使用率） & CF数（使用率） & レジスタ数（使用率） \\ \hline
      プロセッサp32m1 & 71.67& 77.56 & 3838（3％）   & 3804（3％）    & 1379（1％）         \\
      プロセッサp32m2 & 69.57 & 75.35 & 3881（3％）   & 3864（3％）    & 1379（1％）           \\
    \end{tabular}
  \end{table}

  最大動作周波数については，８５℃Model及び０℃Modelともに大方10Mhz程度向上させることができた．しかし，両者のレジスタ数は変わらなかったにも
  かかわらず，LE数およびCF数については１００～２００程度増加した．これは，算術演算子ではなく論理演算を用いたシフト命令や加算命令により，
  論理回路が複雑化したため，FPGA合成の際に増加したものと考えられる．
  %% サブモジュールを３２個並べるより，8を4個，16を２個などのほうが記述もスッキリして早い．

  なお，検討課題４－１を行っている際にここではdiffが出なかったものの，バグが合ったためその修正について\ref{検討結果}章に於いて述べている．


  また，p32p1のp32m1との大きな違いは，IFステージにて，次のステージ(ID)へrelayすると同時に次の命令を読み込むIFステージを生成し，
  次の命令を処理するジョブを生成すること，
  WBステージでは，ジョブを終了（finish）
  データフォワーディング機構（フォワードユニット）があることが挙げられる．

  \section{追加課題や発展課題に関する報告}\label{sec:追加課題や発展課題に関する報告}
  発展課題については，発展課題２－１および発展課題４－１について行った．

  \subsection{発展課題２－１に関する報告}

  mult32サブモジュールについては，算術演算子\verb|*|を用いた形式で実装することが可能であったが，もう一つ組み合わせ回路により，
  加算器を各ビットに設定し，乗数の１が立っているビットがあれば，それを被乗数のビット列と連結させる．はみ出した部分との整合性を
  とるために必要なビット数分右シフトを行わせて実装し，2000パターン解析を行った．

  \subsection{発展課題４－１に関する報告}

  こちらについては，p32m1およびp32m2，p32p1を考察する際に述べているため，\ref{sec:考察１}章を参照されたい．

  \section{検討・考察}\label{sec:検討・考察}

  検討および考察に際し，検討課題１－１，１－２，１－３，検討課題２－１，検討課題４－１について報告をする．
  
  なお，発展課題４－１についての報告の\ref{sec:考察１}章にて演算器およびプロセッサの改良を行っている．
  
  \subsection{検討課題１－１}

  メモリから値をレジスタにロードする命令（lw）の直後に，
  ロードした値を使うようなコードを書いている場合にlwの直後にロードした値を使うと，
  lwはまだ完了していないのでadd命令移動前の値が入っていたり何もない場合があり，参照できないという不具合が発生する．

  \subsection{検討課題１－２}

  ジャンプ/分岐命令の直後（遅延スロット）に，nop 命令が書かれている．
  このnop命令を取り除いた際にジャンプ命令は1サイクル分遅れるため，beqの判定が終わる前にlw命令が実行されてしまい，
  \verb|$t4|レジスタに目的とは異なる値が入ってしまう．そしてその後beqによる移動が起こる．

  \subsection{検討課題１－３}

  ロード命令やジャンプ/分岐命令の直後（遅延スロット）には，nop以外の命令を置くことで，削減できる．
  削減できる箇所としては，lwで読み込みに使うレジスタを使わない命令（例えばlwに利用しないレジスタへのadd命令など）
  ならlwの後に実行しても問題がないので，lwに使うレジスタを利用していないループカウンタをへらす処理などを
  行うようにすることで実行命令数の削減が期待できる．

  確認すると，ループのないところのnop命令をn個削減するとn個の命令数が，
  ループに関わるところのnop命令を削減するとループ数×n個の命令が削減できた．

  \subsection{検討課題２－１}

  演算子\&，\textbar，\textasciitilde，\textasciicircum のこれらの演算子を用いずに全加算器と同じ機能を記述する方法としては，
  論理演算で行っている部分をif文による記述に変更することが考えられる．

  \begin{verbatim}
    def add(a,b,ci): Unit = {
      alt {
        a == 1 && b == 1: co = 0b1
        a == 1 && ci == 1: co = 0b1
        b == 1 && ci == 1: co = 0b1
        else: co = 0b0
      }
      alt {
        a == 1 && b == 0 && ci == 0: out = 0b1
        a == 0 && b == 1 && ci == 0: out = 0b1
        a == 0 && b == 0 && ci == 1: out = 0b1
        a == 1 && b == 1 && ci == 1: out = 0b1
        else: out = 0b0
      }
    }
  \end{verbatim}

  上記の様に，add関数の中身で，altを使いSwitchのようにa，b，ci，のそれぞれの入力値に応じて出力する値を決めることで
  論理演算と同等の処理を実現した．

  \subsection{検討課題４－１}

  メモリのアクセスに遅延がある場合，プログラム実行に要するサイクル数はどのようになるか検討した．具体的な方法は，テストベンチのFSL記述を
  書き換えて行った．IMEM\_LATENCYは命令メモリのアクセス遅延を，DMEM\_LATENCYはデータメモリのアクセス遅延をそれぞれ指定の値だけ行う．

  \subsection{検討結果}\label{検討結果}

  まず，両者の値が０つまり，遅延がないときの各命令は５サイクルで動いていた．
  
  命令メモリのアクセス遅延を１にして実行してみた．
  すると，読み込む前に\verb|read_req|が発生し，１サイクル分遅れていることがわかった．このことから，$n$個の命令があり$m$サイクル分の遅延が
  あるとすると，$(5+m)*n$サイクルが必要となることがわかる．

  次に，データメモリへのアクセス遅延を１にして実行してみた．

  すると，SW,SBの命令において，バグが見つかり，処理が永遠に終わらなかった．WBへ渡す引数の値を修正することで対応できた．
  そして，修正後のプログラムで結果を見てみると，命令メモリのときとは異なり，\verb|S d_read|の命令が実行されているときのみ
  遅延が発生していた．このことから，メモリからの読み込みに$x$サイクルの遅延があり，
  lw,lb等の命令が$y$個ある $n$個の命令の実行には$5*n+x*y$サイクルが必要となる．

  \section{工夫した点や特に力を注いだ点}\label{sec:工夫した点や特に力を注いだ点}

  \begin{itemize}
    \item 実験を実施するにあたって，まずSlackで実験をリモートで行うための事前準備に参加した．
  大まかには，Slackでの情報共有およびScrapBoxへの情報の保存を行った．そして，具体的には，MacおよびUnix系統についてしか
  書かれていなかった実験サーバへのSSH接続のドキュメントを，大半の生徒が使うであろうWindowsを想定したドキュメントを，
  外部サービスQiitaを使い，MarkDown記述を用いて作成した．多くの生徒が参照した有益なドキュメントとなった．
    \item また，実験サーバ上のCUI環境でのプログラム制作が億劫だったため，リモートの環境をローカルで実現しようと，
  wslをWindows環境に入れ込み，SCPコマンドなどを用いて，実験サーバ上の環境と同じものを実現しようと工夫した．
  その後，タイミング解析などに使うソフトをローカルで実現しようとしたが断念．Visual Studio Codeにて，
  SSH接続先のリモート環境のファイルも操作可能ということを見つけ，以降はコマンドラインの実行，ファイルの編集は
  VScode上で行った．ファイルも定期保存されるため，不慮の事故でファイルの変更を失うことがなくスムーズに実験を
  行えた気がする．
    \item プログラム課題，及び設計課題上の工夫としては，基本穴埋め形式だったので，それを埋めるだけではなくきちんと構造を理解するよう努めた．
  オンラインと言う特性を活かし，Slackや講義内で質問を行い解決する努力をした．
  \end{itemize}
  
  \section{本実験を実施して得られたこと}\label{sec:本実験を実施して得られたこと}

  \subsection{目標達成度}

    \begin{table*}[h]
      \caption{目的達成度と自己評価}
      \label{目的達成度と自己評価}
      \begin{center}
        \begin{tabular}{l|l}
          \hline \hline
          項目 &
          達成度（自己評価）
          \\ \hline

          １．ハードウェア設計処理全般（処理の概要と流れ）&
          ５
          \\ 
  
          ２．ハードウェア記述言語（FSL）&
          ６
          \\
          
          ３．ハードウェア設計ツール類使用方法&
          ６
          \\

          ４．プロセッサの命令セットアーキテクチャ&
          ６
          \\

          ５．アセンブリ言語とそれを用いたプログラミング&
          ６
          \\

          ６．プロセッサの動作原理&
          ５
          \\

          ７．プロセッサの設計&
          ５
          \\

          ８．実験報告書&
          ６
          \\

          ９．その他&
          ６
          \\
          \hline

          １０．総合（項目１．～９．の合計）&
          ５１
          \\
          \hline

        \end{tabular}
      \end{center}
    \end{table*}

  \subsection{得られたこと}

  \begin{itemize}
    \item 本実験の目的である，ハードウェア記述言語とCAD（computer aided design）ツールを利用したマイクロプロセッサ設計を通して，
    論理回路，コンピュータアーキテクチャ，およびコンピュータシステムに関する理解を深めることについて達成することができた．

    \item ２年次のコンピュータアーキテクチャおよびオペレーティングシステムの講義で学習していたシステムコールの呼び出しや各種命令の
    各種命令の実行サイクルについて５サイクルで命令が実行されることや，パイプライン方式でのプロセッサの実装とマルチサイクルでのプロセッサの
    実装方式が異なることについて，プログラムを介してその小さな世界を垣間見ることができ，方式の違いによるサイクル数の違いについて詳しく
    理解することができた．

    \item 算術演算はすべて，論理演算に落とし込めるという知見を，add32サブモジュールの全加算器を作成することから得ることができた．
    シフト命令についても，用意されている演算子ではない論理的な実装を行うことでシフトの実装内容を理解できるようになった．

    \item 掛け算がどのようにシフト演算や足し算を用いて行っているのか，当初は理解し難いものだったが，ScrapBoxなどでの他の生徒からの
    アドバイスや先生からの解説により理解を深めることができた．
  \end{itemize}

  \section{おわりに}\label{sec:おわりに}

  今回は，初となるオンラインでの実験であり，色々と戸惑うこともあったがSlackでの質問などでなんとか実験の目的を達成することができた．
  自身の環境の改善など，実験の本質とは異なるものの様々なツール及びコマンドについても知ることができとても有意義なものであった．

  FSL言語や慣れないプロセッサの設計で，時間が多くかかってしまったため解くことができなかった除算の実装や，プロセッサの乗算の実装
  や検討課題があるため，それらが今後の課題として残った．なお，p32p1プロセッサの改良についても行いたい．

  パイプライン方式やマルチサイクルといった技術は現在のプロセッサには欠かせないものとなっているということ，また，マルチコアの並列
  プロセッサの実装についての理解なども深めて行きたい．


  \section{作成した設計記述，プログラム等のリポジトリ名について}\label{sec:作成した設計記述，プログラム等のリポジトリ名，ファイル名の一覧}
  全てのモジュールは本実験で利用したgitbucketの実験用のリポジトリで管理を行った．
  
  URL:http://jikken1.arc.cs.okayama-u.ac.jp/gitbucket/09430509

  \begin{table*}[h]
    \caption{課題に対応するディレクトリ}
    \label{課題に対応するディレクトリ}
    \begin{center}
      \begin{tabular}{l|l}
        \hline \hline
        課題 &
        URL以下のディレクトリ
        \\ \hline

        （プログラミング課題）&
        \\
      
        　１．【プログラミング課題１】N個の語の加算&
        \verb|\prog-kadai1|
        \\ 
      
        　２．【プログラミング課題２】N語のメモリコピー&
        \verb|\prog-kadai2|
        \\ 
      
        　３．【プログラミング課題３】乗算&
        \verb|\prog-kadai3|
        \\
      
        （設計課題２）&
        \\
      
        　４．【設計課題２－１】３２ビット加算器　add32&
        \verb|\add32|
        \\ 
      
        　５．【設計課題２－２】３２ビットALU　alu32&
        \verb|\alu32|
        \\ 
      
        　６．【設計課題２－３】３２ビットシフタ shift32&
        \verb|\shift32|
        \\ 
      
        （発展課題２）&
        \\ 
      
        　７．【発展課題２－１】３２ビット整数乗算器　mult32&
        \verb|\mult32|
        \\
      
        　８．【発展課題２－２】３２ビット整数除算器　div32&
        
        \\
      
        （設計課題３）&
        \\
      
        　９．【設計課題３－１】レジスタファイル　regs32x32&
        \verb|\regs32x32|
        \\ 
      
        １０．【設計課題３－２】実行ユニット　p32ExecUnit&
        \verb|\p32ExecUnit|
        \\ 
      
        １１．【設計課題３－３】デコードユニット p32DecodeUnit&
        \verb|\p32DecodeUnit|
        \\ 
      
        （設計課題４）&
        \\
      
        １２．【設計課題４－１】プロセッサ　p32m1&
        \verb|\p32m1|
        \\ 
      
        １３．【設計課題４－２】プロセッサ　p32m2&
        \verb|\p32m2|
        \\ 
      
        １４．【設計課題４－３】プロセッサ p32p1&
        \verb|\p32p1|
        \\ 
        \\ \hline

      \end{tabular}
    \end{center}
  \end{table*}

  \begin{thebibliography}{99}
    \bibitem{scrap} ScrapBox及び講義資料を参考にした, \verb|https://scrapbox.io/jikken-a/|
  \end{thebibliography}
\end{document}

https://scrapbox.io/jikken-a/p32m2%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E5%90%84%E5%91%BD%E4%BB%A4%E3%81%AE%E5%AE%9F%E8%A1%8C%E3%82%B5%E3%82%A4%E3%82%AF%E3%83%AB%E6%95%B0

VSCodeでsshする前に，自分でwslなど入れて，scpして環境をコピーしていた．

p32p1では遅くなる．

p32m1との大きな違い
n IFステージにて，次のステージ(ID)へrelay すると同時に次の命
令を読み込むIFステージを生成
（次の命令を処理するジョブを生成）
n WBステージでは，ジョブを終了（finish）
n データフォワーディング機構（フォワードユニット）
n p32ForwardingUnit.fsl
n デコードユニット（p32DecodeUnit）はp32m1/p32m2で用いて
ものから一部修正が必要　→ p32DecodeUnit2