【プログラミング課題3】
2個の32ビットの無符号整数値を受取り，それらの積を計算し， 64ビットの乗算結果を返すサブルーチンを作成せよ． サブルーチンへの引数は
被乗数を$a0で，
乗数を$a1
でそれぞれ与え，結果は，
上位ワードを$v0に，
下位ワードを$v1
に格納することとする． 作成したプログラムは，シミュレータにて動作確認を行なうこと．

【ヒント】
乗数の各ビットをLSB側（最下位ビット側）からみて， ビットがたっていたら（ビットが1なら） 被乗数を足し込んでいく処理を繰り返し計算する処理をC言語で記述した例．

/*
 * a0 と a1 の積を計算して，result[0]とresult[1]に格納して返す
 */
void
mul(int *result, unsigned int a0, unsigned int a1) {
    int t0 = 32;              /* ループカウンタ */
    unsigned int v0 = 0;      /* 結果の上位ワードを格納 */
    unsigned int v1 = 0;      /* 結果の下位ワードを格納 */
    for (;;) {
        if (a1 & 1)           /* a1 のLSBが 1 か？ */
            v0 += a0;         /* v0 に a0 を足し込む */
        v1 |= (v0 << 31);     /* v0 のLSBをv1のMSBとする */
        v0 >>= 1;             /* v0 を右シフト */
        if (--t0 == 0) break; /* ループ終了か？ */
        v1 >>= 1;             /* v1 を右シフト */
        a1 >>= 1;             /* a1 を右シフト */
    }
    result[0] = v0;           /* 結果（上位ワード）をメモリに格納 */
    result[1] = v1;           /* 結果（下位ワード）をメモリに格納 */
    return;
} 

/********************************************************************
   4ビットの場合

   (a0)   (a1)     (v0)  (v1)
   0110 x 1010     0000  0000
      6     10        0     0

[step1]
          1010
             ^ 0 なので足し込まない
                   0000  0000
          　　　   0000  0000          ... v0 と v1 が連結しているもの
                                           として右シフト
[step2]
          0101                             
             ^ 1 なのでv0にa0を足し込
                   0110  
          　　　   0011  0000          ... v0 と v1 が連結しているもの
                                           として右シフト
[step3]
          0010
             ^ 0 なので足し込まない
                   0011  0000
          　　　   0001  1000          ... v0 と v1 が連結しているもの
                                           として右シフト
[step4]
          0001
             ^ 1 なのでv0にa0を足し込
                   0111  1000
          　　　   0011  1100          ... v0 と v1 が連結しているもの
                                           として右シフト
 
                   ^^^^  ^^^^
                     result
                           60 (6 x 10)  

********************************************************************/
（if文のアセンブリ言語への変換）
次のif文は下のコード列で実現できる．
(1) else がない場合
if (条件式) 文
==>
            (条件式に対応するコード列，条件式の結果は$v0に格納)
            beq  $v0, $zero, L_ENDIF_001
            (文に対応するコード列)
    L_ENDIF_001:

(2) else がある場合
if (条件式) 文1 else 文2
==>
            (条件式に対応するコード列，条件式の結果は$v0に格納)
            beq  $v0, $zero, L_ELSEIF_001
            nop
            (文1に対応するコード列)
            j    L_ENDIF_001
            nop
    L_ELSEIF_001:
            (文2に対応するコード列)
    L_ENDIF_001:
ここでL_ELSEIF_001やL_ENDIF_001 はラベルであり， 出現するif文毎にそれぞれ異なるラベルを用いる （例えば，別のif文に対しては　L_ELSEIF_002，L_ENDIF_002 など）．
（for文のアセンブリ言語への変換）
次の一般的なfor文は下のコード列で実現できる．
for (式1; 条件式; 式2) 文
==>
            (式1に対応するコード列)
    L_FORLOOP_001:
            (条件式に対応するコード列，条件式の結果は$v0に格納)
            beq  $v0, $zero, L_ENDFOR_001
            nop
            (文に対応するコード列)
            (式2に対応するコード列)
            j    L_FORLOOP_001
            nop
    L_ENDFOR_001:
ここでL_FORLOOP_001，L_ENDFOR_001 はラベルであり， 出現するfor文毎にそれぞれ異なるラベルを用いる （例えば，別のfor文に対しては　L_FORLOOP_002, L_ENDFOR_002 など）． 文の中に，この for文に対応する break文がある場合， このラベルL_ENDFOR_001へジャンプする命令に変換する．

