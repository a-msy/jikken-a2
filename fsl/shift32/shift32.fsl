/* (shift32.fsl) */

module shift32 {
  input    in: Bit(32)
  input shamt: Bit(5)
  output  out: Bit(32)

  // shift left logical
  def sll(in, shamt): Unit = {
    // 簡略
    //out = in << shamt

    val s01 = 0b0
    val s02 = s01 ++ s01
    val s04 = s02 ++ s02
    val s08 = s04 ++ s04
    val s16 = s08 ++ s08
    val t1 = if(shamt(0) == 0b1) in(30,0) ++ s01 else in 
    val t2 = if(shamt(1) == 0b1) t1(29,0) ++ s02 else t1 
    val t3 = if(shamt(2) == 0b1) t2(27,0) ++ s04 else t2 
    val t4 = if(shamt(3) == 0b1) t3(23,0) ++ s08 else t3 
    val t5 = if(shamt(4) == 0b1) t4(15,0) ++ s16 else t4 
    out = t5
  }
  
  // shift right logical
  def srl(in, shamt): Unit = {
    // 簡略
    //out = in >> shamt
    out = shift_right(0b0,in)
  }

  // shift right arithmetic
  def sra(in, shamt): Unit = {
    // 簡略
    //val t0 = 64 # in //inを64bitに拡張してinですべて埋める
    //val t1 = t0 >> shamt
    //out = t1(31,0)
    out = shift_right(in.msb,in)
  }
  private def shift_right(s01: Bit(1), in: Bit(32)): Bit(32) = {
   val s02 = s01 ++ s01
   val s04 = s02 ++ s02
   val s08 = s04 ++ s04
   val s16 = s08 ++ s08
   val t1 = if (shamt(0) == 0b1) s01 ++ in(31, 1)  else in
   val t2 = if (shamt(1) == 0b1) s02 ++ t1(31, 2)  else t1
   val t3 = if (shamt(2) == 0b1) s04 ++ t2(31, 4)  else t2
   val t4 = if (shamt(3) == 0b1) s08 ++ t3(31, 8)  else t3
   val t5 = if (shamt(4) == 0b1) s16 ++ t4(31, 16)  else t4
   t5
 } // private def shift_right
} // module shift32

/* End of file (shift32.fsl) */


